# 189. 轮转数组

## 题目：
给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。

示例 1:
输入: nums = [1,2,3,4,5,6,7], k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右轮转 1 步: [7,1,2,3,4,5,6]
向右轮转 2 步: [6,7,1,2,3,4,5]
向右轮转 3 步: [5,6,7,1,2,3,4]

示例 2:
输入：nums = [-1,-100,3,99], k = 2
输出：[3,99,-1,-100]
解释: 
向右轮转 1 步: [99,-1,-100,3]
向右轮转 2 步: [3,99,-1,-100]

提示：
1 <= nums.length <= 105
-231 <= nums[i] <= 231 - 1
0 <= k <= 105

进阶：
尽可能想出更多的解决方案，至少有 三种 不同的方法可以解决这个问题。
你可以使用空间复杂度为 O(1) 的 原地 算法解决这个问题吗？



## 解题思路：
本题可采用反转数组的方法来解决，具体步骤如下：
1. 处理 k 值：由于轮转 k 次等同于轮转 k % 数组长度 次，因此先将 k 对数组长度取模。
2. 反转整个数组：将整个数组反转，这样可以将需要轮转的元素移到数组前面。
3. 反转前 k 个元素：将数组的前 k 个元素反转，使其顺序恢复正常。
4. 反转剩余元素：将数组中剩余的元素反转，使其顺序恢复正常。
通过这三次反转操作，可以高效地完成数组的轮转，而不需要额外的空间。



## 实现代码：
```java
class Solution {
    public void rotate(int[] nums, int k) {
        int n = nums.length;
        // 处理k大于数组长度的情况，取模后得到实际需要轮转的次数
        k = k % n;
        
        // 反转整个数组
        reverse(nums, 0, n - 1);
        // 反转前k个元素
        reverse(nums, 0, k - 1);
        // 反转剩余的元素
        reverse(nums, k, n - 1);
    }
    
    // 辅助方法：反转数组中从start到end的元素
    private void reverse(int[] nums, int start, int end) {
        while (start < end) {
            // 交换元素
            int temp = nums[start];
            nums[start] = nums[end];
            nums[end] = temp;
            // 移动指针
            start++;
            end--;
        }
    }
}
```



## 复杂度分析：
* 时间复杂度
O(n)，其中 n 是数组的长度。整个数组被反转了三次，每次反转的时间复杂度都是 O(n)，因此总的时间复杂度为 O(n)。
* 空间复杂度
O(1)，只使用了常数级的额外空间。
