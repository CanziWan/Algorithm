# 189. 轮转数组

## 题目：




## 解题思路：
本题可采用排序后遍历的方法来解决，具体步骤如下：
1. 排序区间：首先将所有区间按照起始点从小到大进行排序。这样可以确保相邻的区间更容易进行合并操作。
2. 初始化结果列表：使用一个列表来存储合并后的区间。




## 实现代码：
```java
class Solution {
    public int[][] merge(int[][] intervals) {
        // 如果输入数组为空，直接返回空数组
        if (intervals == null || intervals.length == 0) {
            return new int[0][2];
        }
        
        // 按照区间的起始点进行排序
        Arrays.sort(intervals, Comparator.comparingInt(a -> a[0]));
        
        // 用于存储合并后的区间
        List<int[]> merged = new ArrayList<>();
        // 将第一个区间加入结果列表
        merged.add(intervals[0]);
        
        // 遍历剩余的区间
        for (int i = 1; i < intervals.length; i++) {
            // 获取结果列表中最后一个区间
            int[] lastInterval = merged.get(merged.size() - 1);
            // 当前区间
            int[] current = intervals[i];
            
            // 如果当前区间的起始点小于等于结果列表中最后一个区间的结束点，说明可以合并
            if (current[0] <= lastInterval[1]) {
                // 更新结果列表中最后一个区间的结束点为两者结束点的较大值
                lastInterval[1] = Math.max(lastInterval[1], current[1]);
            } else {
                // 否则，将当前区间直接加入结果列表
                merged.add(current);
            }
        }
        
        // 将列表转换为数组并返回
        return merged.toArray(new int[merged.size()][]);
    }
}
```



## 复杂度分析：
* 时间复杂度
O(nlogn)，其中 n 是区间的数量。主要时间开销在于排序操作，遍历区间的时间复杂度是 O(n)。
* 空间复杂度
O(log n) 或 O(n)，主要取决于排序算法的空间复杂度和存储合并结果的空间。排序的空间复杂度通常是 O(log n)，而存储合并结果的空间复杂度是 O(n)。
