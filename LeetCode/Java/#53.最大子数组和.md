# 53. 最大子数组和

## 题目：
给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
子数组是数组中的一个连续部分。


示例 1：
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。

示例 2：
输入：nums = [1]
输出：1

示例 3：
输入：nums = [5,4,-1,7,8]
输出：23

提示：
1 <= nums.length <= 105
-104 <= nums[i] <= 104

进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。h



## 解题思路：
本题要求找出给定数组 nums 中每个长度为 k 的滑动窗口中的最大值。可以使用双端队列（Deque）来解决这个问题。
* 双端队列的作用
双端队列 deque 用于存储数组元素的索引，并且队列中的元素对应的数组值是单调递减的。也就是说，队列头部的元素对应的数组值是当前窗口中的最大值。
* 具体步骤
	1. 遍历数组：
		* 移除不在窗口内的元素：当队列头部的元素索引小于 i - k 时，说明该元素已经不在当前窗口内，将其从队列头部移除。
		* 维护队列的单调性：从队列尾部开始，移除所有比当前元素小的元素，保证队列头部的元素对应的数组值是当前窗口的最大值。
		* 添加当前元素的索引：将当前元素的索引加入队列尾部。
	2. 记录最大值：当遍历到的元素索引 i 大于等于 k - 1 时，说明窗口已经形成，此时队列头部的元素对应的数组值就是当前窗口的最大值，将其记录到结果数组中。



## 实现代码：
```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        // 处理输入为空或 k 为 0 的情况
        if (nums == null || k <= 0) {
            return new int[0];
        }
        int n = nums.length;
        // 结果数组，长度为 n - k + 1
        int[] result = new int[n - k + 1];
        // 双端队列，用于存储数组元素的索引
        Deque<Integer> deque = new LinkedList<>();

        for (int i = 0; i < n; i++) {
            // 移除队列中不在当前窗口内的元素
            if (!deque.isEmpty() && deque.peekFirst() <= i - k) {
                deque.pollFirst();
            }
            // 移除队列中比当前元素小的元素，保证队列头部是当前窗口的最大值
            while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {
                deque.pollLast();
            }
            // 将当前元素的索引加入队列尾部
            deque.offerLast(i);
            // 当窗口形成后，记录当前窗口的最大值
            if (i >= k - 1) {
                result[i - k + 1] = nums[deque.peekFirst()];
            }
        }
        return result;
    }
}
```



## 复杂度分析：
* 时间复杂度
每个元素最多入队和出队一次，因此时间复杂度为 O(n)，其中 n 是数组 nums 的长度。
* 空间复杂度
双端队列中最多存储 k 个元素，因此空间复杂度为 O(k)。
