# 704.二分查找

## 题目：
给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

示例 1:
输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4

示例 2:
输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1

提示：
你可以假设 nums 中的所有元素是不重复的。
n 将在 [1, 10000]之间。
nums 的每个元素都将在 [-9999, 9999]之间。



## 解答思路：
1. 初始化边界：
首先定义左边界 left 为数组的起始索引 0，右边界 right 为数组最后一个元素的索引（即 nums.length - 1），这样就确定了我们要查找的范围。
2. 循环查找：
只要左边界 left 小于等于右边界 right，就意味着还有范围没有查找完，继续循环执行以下操作：
* 计算中间元素索引：通过 int mid = left + (right - left) / 2 来计算中间元素的索引，这种写法可以避免在计算较大的 left 和 right 之和时出现整数溢出的问题。
* 比较中间元素和目标值：
	* 如果中间元素 nums[mid] 等于目标值 target，那就说明找到了目标值，直接返回中间元素的索引 mid。
	* 如果中间元素 nums[mid] 小于目标值 target，由于数组是升序排列的，所以目标值必然在中间元素的右侧，此时将左边界 left 更新为 mid + 1，这样就把查找范围缩小到了原来范围的右半部分。
	* 如果中间元素 nums[mid] 大于目标值 target，同理，目标值在中间元素的左侧，将右边界 right 更新为 mid - 1，把查找范围缩小到原来范围的左半部分。
3. 未找到情况处理：
当循环结束（即 left > right）时，说明整个数组都查找完了但还是没找到目标值，按照题目要求返回 -1。



## 实现代码：
```java
class Solution {
    public int search(int[] nums, int target) {
        // 定义左边界，初始为数组的起始索引0
        int left = 0;
        // 定义右边界，初始为数组的最后一个元素的索引
        int right = nums.length - 1;

        // 只要左边界小于等于右边界，就继续循环查找
        while (left <= right) {
            // 计算中间元素的索引，这里采用防止溢出的写法
            // 等同于 (left + right) / 2，可以避免整数溢出的问题（不容易超出 int 的范围）
            int mid = left + (right - left) / 2;

            // 如果中间元素等于目标值，直接返回中间元素的索引
            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] < target) {
                // 如果中间元素小于目标值，说明目标值在中间元素的右侧
                // 则将左边界更新为mid + 1，缩小查找范围到右半部分
                left = mid + 1;
            } else {
                // 如果中间元素大于目标值，说明目标值在中间元素的左侧
                // 则将右边界更新为mid - 1，缩小查找范围到左半部分
                right = mid - 1;
            }
        }
        // 如果循环结束还没找到目标值，说明目标值不存在于数组中，返回 -1
        return -1;
    }
}
```



## 复杂度分析：
* 时间复杂度：
每次循环都会将查找范围缩小一半，最多需要进行 log₂n 次（n 为数组 nums 的长度）比较操作就能确定目标值是否存在于数组中，所以时间复杂度为 O(logn)，这是二分查找算法的典型时间复杂度特点。
* 空间复杂度：
整个算法只使用了常数个额外变量（left、right、mid），与输入数组的规模 n 无关，所以空间复杂度为 O(1)，属于非常高效的空间利用，不需要额外的大量空间来辅助查找。
