# 15.三数之和

## 题目：
给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。

示例 1：
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
解释：
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。
注意，输出的顺序和三元组的顺序并不重要。

示例 2：
输入：nums = [0,1,1]
输出：[]
解释：唯一可能的三元组和不为 0 。

示例 3：
输入：nums = [0,0,0]
输出：[[0,0,0]]
解释：唯一可能的三元组和为 0 。

提示：
3 <= nums.length <= 3000
-105 <= nums[i] <= 105



## 解题思路：
1. 边界情况判断与初始化：
	* 首先判断输入的数组 nums 是否为空或者长度小于 3，如果是这样的情况，那就不可能存在满足 a + b + c = 0 的三元组，直接返回空的结果列表。
	* 接着对数组 nums 进行排序，使用 Arrays.sort() 方法。排序后的数组便于后续通过双指针法进行操作以及去重处理。
2. 外层循环确定第一个数：
使用 for 循环来遍历数组，循环变量 i 从 0 开始，到 nums.length - 2 结束（因为至少要给后面的两个指针留出位置）。在每次循环中：
	* 先进行去重操作，通过判断 i > 0 && nums[i] == nums[i - 1]，如果当前 i 位置的数和前一个位置的数相同，那就跳过这次循环，继续下一次 i 的选取，这样可以避免得到重复的三元组结果（因为相同的第一个数后续找出来的组合肯定是重复的）。
	* 然后初始化左指针 left 为 i + 1，即指向 i 后面的第一个元素，右指针 right 为 nums.length - 1，指向数组末尾元素，准备通过双指针法来寻找满足条件的另外两个数。
3. 双指针法寻找另外两个数：
在内部的 while 循环（条件为 left < right）中：
	* 首先计算当前三个数（nums[i]、nums[left] 和 nums[right]）的和 sum。
	* 如果 sum == 0，说明找到了一组满足 a + b + c = 0 的三元组，将这三个数组成的列表添加到结果列表 result 中，然后进行去重操作，分别通过两个 while 循环来跳过左指针和右指针位置上重复的数（保证下一次寻找的组合是不同的），最后将左指针右移一位（left++），右指针左移一位（right--），继续寻找下一组可能的组合。
	* 如果 sum < 0，说明当前三数之和偏小，为了让和增大，需要将左指针 left 右移，因为数组是有序的，左移会使选取的数增大，从而有可能使和更接近 0。
	* 如果 sum > 0，说明当前三数之和偏大，为了让和减小，需要将右指针 right 左移，同理，左移会使选取的数减小，有可能使和达到 0。



## 实现代码：
```java
// 双指针法
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        if (nums == null || nums.length < 3) {
            // 如果数组为空或者长度小于3，不可能存在满足条件的三元组，直接返回空列表
            return result;
        }

        Arrays.sort(nums); // 先对数组进行排序，方便后续去重和双指针法操作

        for (int i = 0; i < nums.length - 2; i++) {
            // 跳过重复的i值，保证每次选取的第一个数不同，避免重复结果
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }

            int left = i + 1;  // 定义左指针，初始指向i后面的第一个元素
            int right = nums.length - 1; // 定义右指针，初始指向数组末尾元素

            while (left < right) {
                int sum = nums[i] + nums[left] + nums[right];
                if (sum == 0) {
                    // 如果三数之和为0，将这三个数组成的列表添加到结果列表中
                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));
                    // 跳过重复的左指针值，避免重复结果
                    while (left < right && nums[left] == nums[left + 1]) {
                        left++;
                    }
                    // 跳过重复的右指针值，避免重复结果
                    while (left < right && nums[right] == nums[right - 1]) {
                        right--;
                    }
                    left++;
                    right--;
                } else if (sum < 0) {
                    // 如果三数之和小于0，说明需要增大和的值，左指针右移
                    left++;
                } else {
                    // 如果三数之和大于0，说明需要减小和的值，右指针左移
                    right--;
                }
            }
        }

        return result;
    }
}
```



## 复杂度分析：
1. 时间复杂度：
	* 首先有一个 Arrays.sort() 函数对数组进行排序，其时间复杂度通常为 O(nlogn)（n 为数组 nums 的长度）。
	* 然后外层 for 循环遍历数组，最多执行 n - 2 次，内层 while 循环中，左指针和右指针最多总共移动 n 次，所以整体时间复杂度主要由排序操作决定，时间复杂度为 O(n^2)，综合起来时间复杂度为 O(n^2)，这里忽略了常数级别的比较和指针移动操作的时间消耗。
2. 空间复杂度：
代码中主要使用了一个 List<List<Integer>> 类型的结果列表来存储满足条件的三元组，在最坏的情况下，所有的组合都满足条件，结果列表的长度最大为 Cn3（组合数），但这仍然是关于 n 的多项式级别，而代码中其他的变量（如指针等）都是常数级别的空间占用，所以空间复杂度可以近似认为是 O(n^2)，不过在实际分析中，通常重点关注结果列表的空间增长情况，由于结果列表的空间取决于满足条件的三元组数量，平均来看会比 O(n^2) 小很多，这里只是一个较宽松的分析情况。
